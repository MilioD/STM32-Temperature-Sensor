/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

void DMA_Init(uint32_t *dest_addr);

void ADC_Init();
void ADC_Enable();
void ADC_Calibrate(); // to-do
void ADC_Start();

void GPIO_Init();

void TIM2_Init();

int main(void)
{
	SystemInit();

	GPIO_init();
	ADC_Init();
	uint32_t dest_addr = 0;
	DMA_Init(&dest_addr);
	TIM2_Init();

	ADC_Enable();
//	ADC_Calibrate(); // to-do
	ADC_Start();

    /* Loop forever */
	for(;;);
}

void GPIO_Init() {
	RCC->AHB1ENR |= (1<<0); // Enable GPIOA RCC Clock

	GPIOA->MODER |= (3<<0); // Set ADC_IN0 (pin PA0) GPIO mode to Analog mode
	GPIOA->OTYPER &= ~(1<<0); // Set GPIO pin to output push-pull type state
	GPIOA->OSPEEDR &= ~(3<<0); // Set GPIO output to low speed

}

void ADC_Init() {
	RCC->APB2ENR |= (1<<8); // Enable ADC RCC Clock

	RCC->CFGR |= (4<<13); // Set PCLK2 (APB2) Clock pre-scaler to 2: 180MHz/2 = 90MHz (ADCCLK & PCLK2)
	ADC->CCR |= (2<<16); // Set ADCCLK (ADC) Clock pre-scaler to 8: 90MHz/6 = 15 MHz (ADCCLK)

	ADC1->CR1 |= (3<<24); // Set resolution to 12-bit
	ADC1->CR2 |= (1<<8); // Enable DMA mode
	ADC1->CR2 &= ~(1<<11); // Set right data alignment
	ADC1->CR2 |= (6<<24); // External event selection set to TIM2 TRGO event trigger
	ADC1->CR2 |= (1<<28); // Conversion on external event enabled Trigger detection on rising edge

	ADC1->SMPR2 |= (7<<0); // Set sampling size to 480 cycles for channel 0: 1/15MHz = 66.66ns | 480*66.66 = 32us
	ADC1->SQR1 &= ~(15<<20); // set length to 1 conversion in the regular channels conversion sequence (only 1 channel)
	ADC1->SQR3 &= ~(0xFFFFFFFF<<0); // Clear/Reset whole regular sequence
	ADC1->SQR3 &= ~(31<<0); // Set ADC_IN0 (ADC1 channel 0) as 1st conversion in regular sequence
	ADC1->CR1 |= (1<<5); // Set End Of Conversion interrupt enable
}

void ADC_Enable() {
	ADC1->CR2 |= (1<<0); // Enable ADC1 (turn on)
}

void ADC_Start() {
	ADC1->SR &= ~(0xFFFFFFFF<<0); // Clear Status Register to reset value
	ADC1->CR2 |= (1<<30); // Set Start Conversion of regular channels (SWSTART)
}

void DMA_Init(uint32_t *dest_addr) {
	RCC->AHB1ENR |= (1<<22); // Enable DMA RCC Clock

	DMA2_Stream0->CR &= ~(7<<25); // DMA2 Stream 0 Configure Channel Selection 0
	DMA2_Stream0->PAR |= (&(ADC1->DR)<<0); // Set DMA2 Stream 0 to transfer data stream from ADC1 peripheral
	DMA2_Stream0->CR &= ~(3<<6); // Set DMA direction to peripheral-to-memory
	DMA2_Stream0->NDTR |= (1<<0); // Set the Number of data transfers to 1
	DMA2_Stream0->M0AR |= (&(*dest_addr)<<0); // Set the destination memory location of data transfer
	DMA2_Stream0->CR |= (1<<8); // Set Circular mode enabled
	DMA2_Stream0->CR |= (1<<11); // Set Peripheral data width to half-word(16-bit)
	DMA2_Stream0->CR |= (1<<13); // Set Memory data width to half-word(16-bit)
	DMA2_Stream0->CR |= (1<<10); // Set Memory Increment mode enable

	// Clear interrupt event flags
	DMA2->LIFCR |= (1<<0);
	DMA2->LIFCR |= (1<<2);
	DMA2->LIFCR |= (1<<3);
	DMA2->LIFCR |= (1<<4);
	DMA2->LIFCR |= (1<<5);

	// Set Interrupt event enable
	DMA2_Stream0->CR |= (1<<4);
	DMA2_Stream0->CR |= (1<<3);
	DMA2_Stream0->CR |= (1<<2);
	DMA2_Stream0->CR |= (1<<1);
}

void DMA_Enable() {
	DMA2_Stream0->CR |= (1<<0); // Enable the DMA2 Stream 0
}

void TIM2_Init() {
	RCC->APB1ENR |= (1<<0); // Set/Enable TIM2 clock
}
